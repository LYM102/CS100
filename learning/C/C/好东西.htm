<!DOCTYPE html>
<html>
<head>
<title>C_benning_1.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="cbeginning">C_Beginning</h1>
<blockquote>
<p>This passage is created by YiMing Li(SHTU)</p>
</blockquote>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行</p>
</blockquote>
<h2 id="c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BAc11">C语言中常见的未定义行为（C11）</h2>
<h3 id="%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9A%E6%9C%AA%E5%AE%9A%E4%B9%89">什么叫做未定义</h3>
<p>未定义行为(undefined behavior)(简称 UB)指编译器允许编译, 但是语言标准中没有定义的行为. 这种现象的出现并不是语言标准不完善, 而是因为这种行为在编译时无法检查其错误或者受限于具体的 cpu 指令以及操作系统优化等使其会有在编译时不可预知的运行结果.</p>
<p>最简单的就是数组越界, 这种错误在 c 语言编译时无法检查, 而 c 标准也没有定义越界后会访问到什么.</p>
<p>未定义行为在不同编译器上或者不同操作系统或者不同架构 cpu 上会产生不同的结果, 所以在任何代码中都应当避免未定义行为.</p>
<h3 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">常见的未定义行为</h3>
<h4 id="%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8Carray-index-outof-bounds">数组越界(array index outof bounds)</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">5</span>] = {<span class="hljs-number">0</span>};
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,<span class="hljs-built_in">array</span>[<span class="hljs-number">5</span>]);
}
</div></code></pre>
<p>而至于 <code>array[5]</code> 到底会访问到什么取决于操作系统和编译器. 例如 windows 平台的 msvc 编译器的 debug 模式会将所有未初始化内存都用特定值来充填, 在未初始化内存的边缘会用另一个值来充填(详见烫烫烫屯屯屯问题). 但是在 linux 平台的 gcc 中此时只会访问到一个普通的未初始化内存, 因此其值是不可预期的.</p>
<p>和数组越界一样的还存在<strong>定义字符串的时候没有存在结束符</strong>的时候，在打印的时候会一直打印，直到看到结束符，所以如果不服你在结束符的时候就会产生越界地情况。</p>
<h4 id="%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F">修改字符串字面量</h4>
<p>字面量(literal)是写在源代码中的表示固定值的符号(token). 平时俗称的硬编码(hard coding)大多数时候就是在说字面量(有时指常量). 举个例子</p>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span> *<span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello"</span>;
<span class="hljs-built_in">string</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">'h'</span>;
</div></code></pre>
<p>上述代码会在第二行产生段错误.</p>
<h4 id="%E9%99%A4%E4%BB%A5%E9%9B%B6">除以零</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> result = a / b;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, result);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89return">有返回值的函数没有return</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{

}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, func());
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="%E5%AD%98%E5%9C%A8%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">存在副作用的子表达式</h4>
<p>副作用(side effect)的意思是函数会对其调用者的上下文中的某些东西产生改变, 比如函数内部改变了全局变量, 或者函数传入值的表达式本身会改变其调用者所在的上下文中的变量.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d "</span>,i++,i);
    retrun <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>(输出 &quot;1 2&quot;)(以 linux 平台的 gcc 编译器为例, 下同)</p>
<p>然后开始盲目分析: &quot;i++&quot; 是用完了再加, 所以输出 1, 而到了第二个参数时 i 已经被加过了, 所以输出 2. 谭浩强直呼闭门大弟子.</p>
<p>那我们来试试给第二个 i 再加 1</p>
<pre class="hljs"><code><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i++, i + <span class="hljs-number">1</span>);
</div></code></pre>
<p>此时同样输出 1 和 2</p>
<pre class="hljs"><code><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i++, i++);
</div></code></pre>
<p>这样甚至输出 2 和 1</p>
<pre class="hljs"><code><div><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, i++, ++i);
</div></code></pre>
<p>这更是输出了不可理喻的 2 和 3</p>
<p>简单地说, 如果一个很长的表达式有多个子表达式, 并且子表达式存在副作用, 那么其运行顺序就是未定义的. 到底是哪个先运行取决于编译器. 所以不要分析了, 这是没有道理的.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">5</span>] = {<span class="hljs-number">0</span>};
<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
<span class="hljs-built_in">array</span>[i] = i++;
</div></code></pre>
<p>像这种因为先运行哪一个函数后运行那一个函数而导致结果不同的情况一般都是UD</p>
<h4 id="%E8%A7%A3%E5%BC%95%E7%94%A8%E7%A9%BA%E6%8C%87%E9%92%88">解引用空指针</h4>
<p>当我们尝试对空指针进行解引用操作的时候编译器无法确定要访问的内存空间中储存的内容。例如：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> *ptr = <span class="hljs-literal">NULL</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,*ptr);
</div></code></pre>
<h4 id="%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">未初始化的局部变量</h4>
<p>当我们使用未初始化的局部变量时，其值是未定义的，因此会导致未定义行为。例如：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> x;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,x);
</div></code></pre>
<h4 id="signed%E6%95%B4%E6%95%B0%E7%9A%84%E6%BA%A2%E5%87%BA">signed整数的溢出</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = INT_MAX;  <span class="hljs-comment">// 假设 INT_MAX 是 2147483647</span>
a++;              <span class="hljs-comment">// 未定义行为</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> b = UINT_MAX;  <span class="hljs-comment">// 假设 UINT_MAX 是 4294967295</span>
b++;                        <span class="hljs-comment">// b 变为 0</span>
</div></code></pre>
<ul>
<li>当使用<code>unsigned</code>的情况的时候，如果你超过范围了就会从最小的开始算起。</li>
</ul>
<h4 id="%E9%94%99%E8%AF%AF%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E9%94%99%E8%AF%AF%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E5%8C%B9%E9%85%8D">错误的类型转换以及错误的格式输出的匹配</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
<span class="hljs-keyword">float</span> *fptr = (<span class="hljs-keyword">float</span> *)ptr; <span class="hljs-comment">// 错误的类型转换，结果未定义</span>
</div></code></pre>
<h4 id="%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%B9%B6%E4%B8%8D%E5%8C%B9%E9%85%8D">函数参数数量并不匹配</h4>
<p>调用函数时提供的参数数量与函数定义不匹配，如<code>printf(&quot;%s %d&quot;,&quot;Name&quot;);</code></p>
<h3 id="%E7%BB%83%E4%B9%A0from-shtu">练习（From SHTU）</h3>
<ul>
<li>假设<code>int</code>类型是32位的。选择设计未定义行为的代码片段</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">unsigned</span> uval = <span class="hljs-number">-111</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%u%%\n"</span>, uval);
</div></code></pre>
<ul>
<li>这个是正确的，因为这是<code>unsigned</code>的内容所以不会超过循环而是从头开始。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> x = <span class="hljs-number">96</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>, x/<span class="hljs-number">100</span>);
</div></code></pre>
<ul>
<li>这里是未定义行为，这里的<code>%f</code>适用于<code>float</code>的数值，而这里属于错误匹配格式化输出符。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d%d\n"</span>, ++i, i);
</div></code></pre>
<ul>
<li>这是经典的副作用的未定义的情况，这里的<code>i</code>和<code>++i</code>无法确定哪一个会先被调用</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"value is %d\n"</span>, value);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> x = helper(<span class="hljs-number">42</span>);
  <span class="hljs-keyword">int</span> y = helper(x);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, x + y);
}
</div></code></pre>
<ul>
<li>这里涉及设计了没有返回值的情况，也是未定义行为</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> x;
  <span class="hljs-keyword">return</span> x;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">random</span>());
}
</div></code></pre>
<ul>
<li>这里涉及没有定义自变量的情况</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">lim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> condition, <span class="hljs-keyword">double</span> formula)</span></span>{
    <span class="hljs-keyword">double</span> d = <span class="hljs-number">0.000618</span>, dx = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">return</span> condition ? <span class="hljs-number">0</span> : d*formula/dx;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-keyword">int</span> _x = <span class="hljs-number">1</span>, x = <span class="hljs-number">4399</span>, inf = <span class="hljs-number">2147483647</span>;
    <span class="hljs-keyword">double</span> e = lim(_x --&gt; inf, (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>/x)^x);
}
</div></code></pre>
<ul>
<li>这并不是一个未定义的代码，而是一个语法错误的代码</li>
</ul>
<h2 id="%E4%BA%86%E8%A7%A3scanf">了解<code>scanf()</code></h2>
<ul>
<li><code>scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</code>和<code>scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</code>之间到底是什么关系？
<ol>
<li>在C中<code>' '</code>,<code>'\n'</code>,<code>'\f'</code>,<code>'\t'</code>,<code>'\v'</code>;这几个都叫做空白字符，而在<code>scanf</code>中的<code>%d</code>和空白字符可以跳过任意的空白字符</li>
<li>当且仅当遇到下一个非空字符的时候才会去对应到下一个值，或推退出语句</li>
</ol>
</li>
<li><code>scanf()</code>的返回值
<ul>
<li>如果<code>scnaf()</code>返回值是合法的，<code>scanf()</code>的返回值和预期输入数量匹配。</li>
<li>如果<code>scnaf()</code>返回值是非法的，<code>scnaf()</code>的返回值是零。
<strong>示例</strong></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> num;
<span class="hljs-keyword">float</span> fnum;
<span class="hljs-keyword">int</span> result = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %f"</span>, &amp;num, &amp;fnum);
<span class="hljs-keyword">if</span> (result == <span class="hljs-number">2</span>) {
    <span class="hljs-comment">// 输入合法</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 输入不合法</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> num;
<span class="hljs-keyword">int</span> result = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
<span class="hljs-keyword">if</span> (result == EOF) {
    <span class="hljs-comment">// 输入结束或错误</span>
}
</div></code></pre>
<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</h2>
<h3 id="%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F">不同类型的字节大小</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">32位</th>
<th style="text-align:center">64位</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>始终为 1 字节</strong>，表示单个字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>short int</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">通常为 2 字节，表示短整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">通常为 4 字节，表示整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>long int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">在 32 位系统中通常为 4 字节，在 64 位系统中通常为 8 字节，表示长整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>long long int</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">始终为 8 字节，表示长长整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">始终为 4 字节，表示单精度浮点数。</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">始终为 8 字节，表示双精度浮点数。</td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">12 或 16</td>
<td style="text-align:center">16</td>
<td style="text-align:center">在 32 位系统中通常为 12 或 16 字节，在 64 位系统中通常为 16 字节，表示扩展精度浮点数。</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned char</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">始终为 1 字节，表示无符号字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned short</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">通常为 2 字节，表示无符号短整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">通常为 4 字节，表示无符号整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">在 32 位系统中通常为 4 字节，在 64 位系统中通常为 8 字节，表示无符号长整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">始终为 8 字节，表示无符号长长整数。</td>
</tr>
<tr>
<td style="text-align:center"><code>void*</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">在 32 位系统中通常为 4 字节，在 64 位系统中通常为 8 字节，表示指针。</td>
</tr>
<tr>
<td style="text-align:center"><code>_Bool</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">始终为 1 字节，表示布尔值（0 或 1）。</td>
</tr>
<tr>
<td style="text-align:center"><code>enum</code></td>
<td style="text-align:center">通常与 <code>int</code> 相同</td>
<td style="text-align:center">通常与 <code>int</code> 相同</td>
<td style="text-align:center">枚举类型的大小通常与 <code>int</code> 类型相同。</td>
</tr>
</tbody>
</table>
<h3 id="%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%AC%A6%E5%8D%A0%E4%BD%8D%E7%AC%A6">不同类型的格式转换符（占位符）</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center"><code>printf</code> 占位符</th>
<th style="text-align:center"><code>scanf</code> 占位符</th>
<th style="text-align:center">示例值</th>
<th style="text-align:center">示例代码（<code>printf</code>）</th>
<th style="text-align:center">示例代码（<code>scanf</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>%c</code></td>
<td style="text-align:center"><code>%c</code></td>
<td style="text-align:center"><code>'A'</code></td>
<td style="text-align:center"><code>printf(&quot;%c&quot;, 'A');</code></td>
<td style="text-align:center"><code>scanf(&quot;%c&quot;, &amp;ch);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>%d</code> 或 <code>%i</code></td>
<td style="text-align:center"><code>%d</code> 或 <code>%i</code></td>
<td style="text-align:center"><code>42</code></td>
<td style="text-align:center"><code>printf(&quot;%d&quot;, 42);</code></td>
<td style="text-align:center"><code>scanf(&quot;%d&quot;, &amp;num);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center"><code>%u</code></td>
<td style="text-align:center"><code>%u</code></td>
<td style="text-align:center"><code>42</code></td>
<td style="text-align:center"><code>printf(&quot;%u&quot;, 42);</code></td>
<td style="text-align:center"><code>scanf(&quot;%u&quot;, &amp;unum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>short int</code></td>
<td style="text-align:center"><code>%hd</code></td>
<td style="text-align:center"><code>%hd</code></td>
<td style="text-align:center"><code>42</code></td>
<td style="text-align:center"><code>printf(&quot;%hd&quot;, (short)42);</code></td>
<td style="text-align:center"><code>scanf(&quot;%hd&quot;, &amp;snum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned short</code></td>
<td style="text-align:center"><code>%hu</code></td>
<td style="text-align:center"><code>%hu</code></td>
<td style="text-align:center"><code>42</code></td>
<td style="text-align:center"><code>printf(&quot;%hu&quot;, (unsigned short)42);</code></td>
<td style="text-align:center"><code>scanf(&quot;%hu&quot;, &amp;usnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long int</code></td>
<td style="text-align:center"><code>%ld</code></td>
<td style="text-align:center"><code>%ld</code></td>
<td style="text-align:center"><code>42L</code></td>
<td style="text-align:center"><code>printf(&quot;%ld&quot;, 42L);</code></td>
<td style="text-align:center"><code>scanf(&quot;%ld&quot;, &amp;lnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center"><code>%lu</code></td>
<td style="text-align:center"><code>%lu</code></td>
<td style="text-align:center"><code>42L</code></td>
<td style="text-align:center"><code>printf(&quot;%lu&quot;, 42L);</code></td>
<td style="text-align:center"><code>scanf(&quot;%lu&quot;, &amp;ulnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long long int</code></td>
<td style="text-align:center"><code>%lld</code></td>
<td style="text-align:center"><code>%lld</code></td>
<td style="text-align:center"><code>42LL</code></td>
<td style="text-align:center"><code>printf(&quot;%lld&quot;, 42LL);</code></td>
<td style="text-align:center"><code>scanf(&quot;%lld&quot;, &amp;llnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long</code></td>
<td style="text-align:center"><code>%llu</code></td>
<td style="text-align:center"><code>%llu</code></td>
<td style="text-align:center"><code>42LL</code></td>
<td style="text-align:center"><code>printf(&quot;%llu&quot;, 42LL);</code></td>
<td style="text-align:center"><code>scanf(&quot;%llu&quot;, &amp;ullnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>%f</code></td>
<td style="text-align:center"><code>%f</code></td>
<td style="text-align:center"><code>3.14f</code></td>
<td style="text-align:center"><code>printf(&quot;%f&quot;, 3.14f);</code></td>
<td style="text-align:center"><code>scanf(&quot;%f&quot;, &amp;fnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>%f</code> 或 <code>%lf</code></td>
<td style="text-align:center"><code>%lf</code></td>
<td style="text-align:center"><code>3.14</code></td>
<td style="text-align:center"><code>printf(&quot;%f&quot;, 3.14);</code></td>
<td style="text-align:center"><code>scanf(&quot;%lf&quot;, &amp;dnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center"><code>%Lf</code></td>
<td style="text-align:center"><code>%Lf</code></td>
<td style="text-align:center"><code>3.14L</code></td>
<td style="text-align:center"><code>printf(&quot;%Lf&quot;, 3.14L);</code></td>
<td style="text-align:center"><code>scanf(&quot;%Lf&quot;, &amp;ldnum);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char[]</code> 或 <code>char*</code></td>
<td style="text-align:center"><code>%s</code></td>
<td style="text-align:center"><code>%s</code></td>
<td style="text-align:center"><code>&quot;Hello&quot;</code></td>
<td style="text-align:center"><code>printf(&quot;%s&quot;, &quot;Hello&quot;);</code></td>
<td style="text-align:center"><code>scanf(&quot;%s&quot;, str);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>void*</code></td>
<td style="text-align:center"><code>%p</code></td>
<td style="text-align:center">N/A</td>
<td style="text-align:center"><code>&amp;var</code></td>
<td style="text-align:center"><code>printf(&quot;%p&quot;, &amp;var);</code></td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center"><code>_Bool</code></td>
<td style="text-align:center"><code>%d</code></td>
<td style="text-align:center"><code>%d</code></td>
<td style="text-align:center"><code>true</code> 或 <code>false</code></td>
<td style="text-align:center"><code>printf(&quot;%d&quot;, true);</code></td>
<td style="text-align:center"><code>scanf(&quot;%d&quot;, &amp;boolvar);</code></td>
</tr>
</tbody>
</table>
<h3 id="%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">不同进制的表示方式</h3>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">十六进制</th>
<th style="text-align:center">八进制</th>
<th style="text-align:center">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>\x41</code></td>
<td style="text-align:center"><code>\0101</code></td>
<td style="text-align:center"><code>\65</code>/<code>65</code></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>0x41</code></td>
<td style="text-align:center"><code>0101</code></td>
<td style="text-align:center"><code>65</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center"><code>0x41u</code></td>
<td style="text-align:center"><code>0101u</code></td>
<td style="text-align:center"><code>65u</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><code>0x41L</code></td>
<td style="text-align:center"><code>0101L</code></td>
<td style="text-align:center"><code>65L</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center"><code>0x41UL</code></td>
<td style="text-align:center"><code>0101UL</code></td>
<td style="text-align:center"><code>65UL</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center"><code>0x41LL</code></td>
<td style="text-align:center"><code>0101LL</code></td>
<td style="text-align:center"><code>65LL</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long</code></td>
<td style="text-align:center"><code>0x41ULL</code></td>
<td style="text-align:center"><code>0101ULL</code></td>
<td style="text-align:center"><code>65ULL</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>0x1.9p-4f</code></td>
<td style="text-align:center"><code>01.443242e-4f</code></td>
<td style="text-align:center"><code>6.5f</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>0x1.9p-4</code></td>
<td style="text-align:center"><code>01.443242e-4</code></td>
<td style="text-align:center"><code>6.5</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned float</code></td>
<td style="text-align:center"><code>0x1.9p-4uf</code></td>
<td style="text-align:center"><code>01.443242e-4uf</code></td>
<td style="text-align:center"><code>6.5uf</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center"><code>0x1.9p-4L</code></td>
<td style="text-align:center"><code>01.443242e-4L</code></td>
<td style="text-align:center"><code>6.5L</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long double</code></td>
<td style="text-align:center"><code>0x1.9p-4uL</code></td>
<td style="text-align:center"><code>01.443242e-4uL</code></td>
<td style="text-align:center"><code>6.5uL</code></td>
</tr>
</tbody>
</table>
<h3 id="c%E8%AF%AD%E8%A8%80%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%B8%8Eint%E7%9A%84%E5%85%B3%E7%B3%BB">C语言逻辑运算结果类型及与int的关系</h3>
<ul>
<li>C语言逻辑运算结果类型及与int的关系:
在C语言中，逻辑运算的结果类型和值有明确的定义。即使在C99标准引入布尔类型后，逻辑运算的结果仍然可以被看作是int类型。以下是详细解释。</li>
</ul>
<ol>
<li>C99标准引入的布尔类型</li>
</ol>
<ul>
<li>C99标准引入了<code>_Bool</code>类型，表示布尔值（<code>true</code>或<code>false</code>），并通过<code>stdbool.h</code>头文件提供了<code>bool</code>类型别名，以及<code>true</code>和<code>false</code>宏定义。例如：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;
</div></code></pre>
<ul>
<li>_Bool类型是一个独立的类型，其大小通常为1字节，且只有两个可能的值：<code>true</code>（非零值）<code>false</code>（零值）</li>
</ul>
<ol start="2">
<li>逻辑运算的结果类型</li>
</ol>
<ul>
<li>尽管引入了布尔类型，但C语言的逻辑运算（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）的结果类型仍然是<code>int</code>，而不是<code>_Bool</code>。原因如下：
<ul>
<li>历史兼容性：C语言的逻辑运算结果一直是<code>int</code>类型，为了保持与早期代码的兼容性，C99标准没有改变这一行为。</li>
<li>隐式转换：在C语言中，<code>_Bool</code>类型可以隐式转换为<code>int</code>类型，反之亦然。因此，即使逻辑运算的结果是int类型，它也可以被用在布尔上下文中。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>
<p>逻辑运算结果的值
逻辑运算的结果值仍然是0或1：</p>
<ul>
<li>
<p>0表示false（假）。</p>
</li>
<li>
<p>1表示true（真）。</p>
</li>
</ul>
<p>这意味着，即使你使用bool类型来存储逻辑运算的结果，它也会被隐式转换为int类型。例如：</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">bool</span> result = (<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 逻辑运算结果为 1（true）</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">" =result %d\n"</span>, result); <span class="hljs-comment">// 输出 1</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(result) = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(result)); <span class="hljs-comment">// 输出 1（_Bool类型大小）</span>
    
    <span class="hljs-keyword">int</span> int_result = (<span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 逻辑运算结果为 1（int类型）</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"int_result = %d\n"</span>, int_result); <span class="hljs-comment">// 输出 1</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(int_result) = %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(int_result)); <span class="hljs-comment">// 输出 4（int类型大小）</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ol start="4">
<li>为什么可以将结果看作<code>int</code>类型</li>
</ol>
<ul>
<li>类型兼容性：<code>_Bool</code>类型和<code>int</code>类型之间可以隐式转换。<code>_Bool</code>类型在存储时通常会被提升为<code>int</code>类型，因此逻辑运算的结果（<code>int</code>类型）可以直接赋值给<code>_Bool</code>类型变量。</li>
<li>值兼容性：逻辑运算的结果只有0和1，这两个值在<code>int</code>类型和<code>_Bool</code>类型中都具有相同的语义。</li>
</ul>
<h3 id="%E8%AE%A1%E7%AE%97%E6%97%B6%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">计算时的隐式转换</h3>
<ul>
<li><code>char</code>和<code>short</code>类型在运算的时候发生隐式转换位<code>int</code>。但是只会在计算或者比较大小的时候发生转变，在计算完成之后就还是原来的类型。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">char</span> a = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">char</span> b = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">char</span> c = a + b;<span class="hljs-comment">//先变成int，再变成char</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a + b = %d\n"</span>, c);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    short a = <span class="hljs-number">5</span>;
    short b = <span class="hljs-number">10</span>;
    short c = a + b;<span class="hljs-comment">//会先转换为int然后再变成short</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a + b = %d\n"</span>, c);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%83%85%E5%86%B5">未定义的情况</h3>
<ol>
<li>超过范围的情况：例如int超过范围</li>
<li>未使用正确的占位符</li>
<li><code>i++ + ++i</code>的情况</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">char</span> b = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c = <span class="hljs-number">64L</span>L;
    <span class="hljs-keyword">float</span> d = <span class="hljs-number">64.00</span>;
    <span class="hljs-keyword">double</span> e = <span class="hljs-number">64.00</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> f = <span class="hljs-number">64</span>;
    short g = <span class="hljs-number">64</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f,%lld,%c,%hd,%u\n"</span>, a, a, a, a, a);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f,%lld,%d,%hd,%u\n"</span>, b, b, b, b, b);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f,%d,%c,%hd,%u\n"</span>, c, c, c, c, c);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d,%lld,%c,%hd,%u\n"</span>, d, d, d, d, d);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d,%lld,%c,%hd,%u\n"</span>, e, e, e, e, e);
}
</div></code></pre>
<pre class="hljs"><code><div>0.000000,64,@,64,64
0.000000,64,64,64,64
0.000000,64,@,64,64
0,4634204016564240384,,0,0
0,4634204016564240384,,0,0
</div></code></pre>
<h2 id="%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</h2>
<h3 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7">运算符的优先级和结合性</h3>
<p>以下是C语言中不同运算符的优先级和结合性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>()</code></td>
<td style="text-align:center">圆括号</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>[]</code></td>
<td style="text-align:center">数组下标</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">结构体成员访问</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>-&gt;</code></td>
<td style="text-align:center">结构体指针成员访问</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>++</code></td>
<td style="text-align:center">后置递增</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>--</code></td>
<td style="text-align:center">后置递减</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>++</code></td>
<td style="text-align:center">前置递增</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>--</code></td>
<td style="text-align:center">前置递减</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">一元加</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">一元减</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">逻辑非</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">按位取反</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">指针解引用</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">取地址</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>sizeof</code></td>
<td style="text-align:center">求大小</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>(type)</code></td>
<td style="text-align:center">类型转换</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">乘法</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">除法</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">取模</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">加法</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">减法</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">左移</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">右移</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">小于</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">大于</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">等于</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">按位与</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><code>\|\|</code></td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><code>?:</code></td>
<td style="text-align:center">条件运算符</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">赋值</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td>
<td style="text-align:center">复合赋值运算符</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>\|=</code></td>
<td style="text-align:center">复合赋值运算符</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"><code>,</code></td>
<td style="text-align:center">逗号运算符</td>
<td style="text-align:center">从左到右</td>
</tr>
</tbody>
</table>
<h3 id="%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%8E%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A6%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98">算数运算与算数运算的左连接问题</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> ival = <span class="hljs-number">100000</span>;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> llval = ival;
    <span class="hljs-keyword">int</span> res1 = ival * ival;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res2 = ival * ival;<span class="hljs-comment">//运算结果是int再显示转换为longlong还是会溢出</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res3 = llval * ival;<span class="hljs-comment">//在运算的时候ival隐式转换成long long在进行计算</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res4 = llval * ival * ival;<span class="hljs-comment">//注意是从左向右的方式进行两个ival依次被转换成longlong类型</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n%lld\n%lld\n%lld\n"</span>, res1, res2, res3, res4);
    <span class="hljs-comment">/*
    1410065408
    1410065408
    10000000000
    1000000000000000
    */</span>
}
</div></code></pre>
<h3 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%9A%84%E5%8F%B3%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98">赋值运算的右连接问题</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">2</span>;
    a = b = c;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d"</span>, a, b, c);<span class="hljs-comment">//2 2 2</span>
    <span class="hljs-comment">// 赋值运算从右往左进行</span>
}
</div></code></pre>
<h3 id="%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">未定义的函数调用顺序</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Func1 is called\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Func2 is called\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Func3 is called\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> c = func1() + (func2() * func3());
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre class="hljs"><code><div>Func1 is called
Func2 is called
Func3 is called
</div></code></pre>
<ul>
<li>Operater precedence does not determine evaluation order:<code>f()+g()*h()</code> is interpreted as <code>f() + (g() * h())</code>,but the order in which <code>f</code>,<code>g</code>,<code>h</code> are called is unspecified.</li>
<li>也就是说在对于不同函数的调用<code>a()+b()+c()</code>中，由于<code>operator+</code>的原因从左到右的结合性分析成为<code>(a()+b())+c()</code>，但是在运行时可以首先，最后或者在中间运行<code>c()</code></li>
<li>个人的情况，其实我觉得函数的调用应该还是按照从左往右的顺序进行，但是如果是遇到逻辑判断则会出现短路现象（只要能够判断是否是真或者是假就会跳过相关的函数的调用）</li>
</ul>
<h2 id="static-local%E5%8F%98%E9%87%8F%E5%92%8Cglobal%E5%8F%98%E9%87%8F"><code>static local</code>变量和<code>global</code>变量</h2>
<ul>
<li><code>static local</code>变量表示的是在局部声明的整体变量，他们和<code>global</code>变量一样如果没有进行初始化就会被默认为初始化为0（不同类型的0模式，同样的如果是指针都是表示的是空指针）</li>
<li>同样的<code>global</code>变量，在全局作用域外部定义的变量，这一些变量在整个程序中都可以使用</li>
<li><code>static local</code>和<code>global</code>变量的声明都是在整个程序开始运行的时候进行声明的。同时也是在整个程序结束之后在消除的。</li>
<li>例子：使用全局变量完成的只能调用一次的函数的书写</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> start_game_called = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_game</span><span class="hljs-params">(Player *p1, Player *p2, <span class="hljs-keyword">int</span> difficulty, GameWorld *world)</span> </span>{
<span class="hljs-keyword">if</span> (start_game_called)
report_an_error(<span class="hljs-string">"You cannot start the game twice!"</span>);
start_game_called = <span class="hljs-literal">true</span>;
<span class="hljs-comment">// ...</span>
}
</div></code></pre>
<h2 id="%E6%8C%87%E9%92%88">指针</h2>
<h3 id="%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89">指针的定义</h3>
<pre class="hljs"><code><div>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> *ptr1 = &amp;a;
    <span class="hljs-keyword">int</span>* ptr1 = &amp;a;<span class="hljs-comment">//两种写法都是正确的</span>
    <span class="hljs-keyword">int</span>     *   ptr4 = &amp;a;<span class="hljs-comment">//空格不影响</span>
    <span class="hljs-keyword">int</span>*ptr5 = &amp;a;<span class="hljs-comment">//没有空格也可以</span>
    <span class="hljs-keyword">int</span> *ptr2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//空指针定义</span>
    <span class="hljs-keyword">int</span> *ptr3 = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//空指针定义</span>
    <span class="hljs-keyword">int</span> *ptr6 = &amp;<span class="hljs-number">2</span>;<span class="hljs-comment">//错误的定义方式</span>
    <span class="hljs-keyword">int</span> *ptr7 = &amp;(<span class="hljs-number">2</span>*a);<span class="hljs-comment">//错误的定义方式</span>
</div></code></pre>
<p>这里的指针指向的内容必须要是一个左值（表示能够写在左侧的值）<code>int c = a+b</code>这里的<code>c</code>就是左值。</p>
<p>空指针是正确的但是空指针不能够解引用（这样也就导致了空指针是不能够赋值的）打印空指针的内容可以看到<code>0000000000000000</code>,因此为了避免空指针的使用，我们常常这么写：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (ptr != <span class="hljs-literal">NULL</span> &amp;&amp; *ptr == <span class="hljs-number">42</span>) { <span class="hljs-comment">/* ... */</span> }
</div></code></pre>
<p>这样如果指针式空的，那么后面解引用的过程就不会发生</p>
<ul>
<li>野指针：野指针表示的就是没有初始值的指针，这一些指针因为不知道具体值以及地址所以几乎不能够使用，这也是未定义的行为中的一种。</li>
<li>悬垂指针：表示的是已经释放内存地址的指针，同样的这个也是不好的</li>
</ul>
<p>例子：</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> *p = method();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">method</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> *p = &amp;p;
    <span class="hljs-keyword">return</span> *p;
}
</div></code></pre>
<p>解释：因为在函数中的元素在函数外部将会释放它的内存地址，因此<code>method</code>传出的参数在函数的外部会将所储存的元素释放。</p>
<h3 id="%E6%8C%87%E9%92%88%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0">指针传入函数</h3>
<p>指针传入函数中是指针的副本，如果在函数中通过指针对变量进行改变，这是正确的，但是如果在函数中通过指针本身对指针进行改变（例如交换）这个只在函数内部有效，如果要实现这个功能必须要使用双重指针来传入<code>swap(&amp;p1,&amp;p2)</code>,<code>void swap(int **p1,int **p2) int *temp = p1;p1 = p2;p2 = temp;</code>这样才行</p>
<h3 id="const%E6%8C%87%E9%92%88"><code>const</code>指针</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> *p1 = &amp;a; <span class="hljs-comment">// const int *p1 = &amp;a;</span>
    p1 = &amp;b;
    <span class="hljs-comment">// *p1 = 10;    Error! the pointer is read-only</span>
    <span class="hljs-comment">// a = 10; Correct!</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, *p1);<span class="hljs-comment">//Prints 10</span>
}
</div></code></pre>
<p><code>const int *ptr</code>表示的是这个指针受到保护，不能够通过这个指针来修改变量的数值。但是可以通过改变指针所指向的对象来进行修改（可以指向另外一个变量）或者是直接改变变量a来进行修改这个和<code>int const*p1 = &amp;a;</code>的结果是一样的。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> *p1 = &amp;a;
    p1 = &amp;b;<span class="hljs-comment">// Warning</span>
    *p1 = <span class="hljs-number">10</span>;<span class="hljs-comment">//Warning</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, *p1); <span class="hljs-comment">// Prints 10</span>
}
</div></code></pre>
<p>可以通过指针来改变<code>const int</code>的内容，这里编译器报警，但是不会导致程序不运行，这里相当于使用<code>*p1</code>对<code>const int</code>所做的操作都是检查不出问题的（这是<code>UNdefined Behaviors</code>）</p>
<p>如果我们希望这个指针只能指向这一个变量而不能够指向其他的变量，那么我们应该使用<code>int *const pc</code>来确定一个<code>Top-locked pointer</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> x = <span class="hljs-number">42</span>;
<span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> pc = &amp;x;
++*pc; <span class="hljs-comment">// OK.</span>
<span class="hljs-keyword">int</span> y = <span class="hljs-number">30</span>;
pc = &amp;y; <span class="hljs-comment">// Error</span>
</div></code></pre>
<p>在这个例子中我们注意到，这里的指针不能够通过赋值其他的变量的地址来进行对指针内容进行修改，但是可以通过指针来修改变量的数值，也可以直接对变量的内容进行修改（变量没有受到<code>const</code>的限制）</p>
<p>所以这样的话我们有最高的上锁的指针
<code>const int *const cipc = &amp;x</code>也就是说不能够对他赋值，也不能够转换指针指向的对象。</p>
<h3 id="void"><code>void*</code></h3>
<p><code>void*</code>表示的是一个知识指向地址的指针。所以<code>void*</code>可以转换成为任意类型的指针，而任何其他的指针也能够转换成<code>void*</code></p>
<h2 id="%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88">数组与指针</h2>
<h3 id="%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86">数组的基本知识</h3>
<ul>
<li>数组只能够通过对其中的元素赋值来修改,不能够在<code>main</code>函数中使用<code>b = {1,2,3}</code>这样的方式进行赋值</li>
<li>数组的类型是<code>int [M]</code>而不是<code>int *</code>虽然在使用的时候他会转换成为首地址的形式</li>
<li>数组在函数中表示的首地址只能够获取不能够修改，相当于<code>const int *p</code>,但是与之不同的是，可以通过解引用的方式对<code>arr</code>的首元素进行修改,即<code>*arr</code>相当于<code>arr[0]</code>.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> arr_1[] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
    <span class="hljs-keyword">int</span> arr_2[] = {<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>};
    <span class="hljs-comment">// arr_1 = arr_2;这样是错误的，因为数组的首地址是不能够修改的</span>
    <span class="hljs-keyword">int</span> *p1 = arr_1;
    <span class="hljs-keyword">int</span> *p2 = arr_2;
    <span class="hljs-keyword">void</span> *temp;
    temp = p1;
    p1 = p2;
    p2 = (<span class="hljs-keyword">int</span> *)temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, p1[i]);<span class="hljs-comment">//prints 789</span>
}
</div></code></pre>
<ul>
<li>如果要通过指针的形式来遍历数组，请使用指针变量来接受数组的地址。</li>
<li>数组的初始化
<ul>
<li><code>int arr[100] = {1}</code>:表示的是第一个元素为<code>1</code>，后面的元素都是<code>0</code>.</li>
<li><code>char arr[100] = &quot;1&quot;</code>：表示的是第一个元素为<code>'1'</code>后面的元素是<code>'\0'</code>，因为<code>'\0'</code>的ASCII码为0.</li>
</ul>
</li>
</ul>
<h3 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89">二维数组的定义</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    arr[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = 
    {
        {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>},
        {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}
    };
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
{
    <span class="hljs-keyword">int</span> arr1[<span class="hljs-number">4</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
    <span class="hljs-keyword">int</span> arr2[<span class="hljs-number">4</span>] = {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>};
    <span class="hljs-keyword">int</span> *arr[<span class="hljs-number">2</span>] = {arr1,arr2};
    <span class="hljs-comment">// 解释:int* 表示存放的内容是指针,arr 表示的是这个指针数组的名称叫做arr.</span>
}
</div></code></pre>
<p>区别，第一种规定的两个数组的长度应该相同，但是第二种对两个数组的长度没有限制。注意，这个时候的占用空间就变成有其中的指针的占用空间了。</p>
<h3 id="%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%9D%A5%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">使用指针来遍历二维数组</h3>
<p>定义<code>int arr[3][5]</code>的指针：<code>int (*p)[5] = arr;</code>,解释：因为<code>int [5]</code>表示的是指针所指的是一个长度为5的一个类型(也就是所指的是数组的首地址)，<code>*p</code>表示的是这是一个指针，并且指针的名称为<code>p</code>.</p>
<p>其中这里的<code>arr + 1</code>表示的是移动<code>int [5]</code>个单位，也就是说直接移动的长度是<code>arr</code>中整个子数组的长度</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">5</span>] = arr;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>;i++)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,(*p)++);
    }
    p++;
}
</div></code></pre>
<p>如果是按照<code>int *arr[2] = {arr1,arr2};</code>来定义的二维数组的话<code>int **p = arr;</code>这里指向的类型是<code>arr</code>的首地址，也就是<code>arr1</code>，即指向<code>int</code>的指针。</p>
<p>遍历的过程当中要注意</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> **p = arr;<span class="hljs-comment">//这里是指向指针的指针，因为这里的arr表示的是一个指针的数组</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len[i]; j++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, *(*p + j));
    }
    p++;<span class="hljs-comment">//移动到其中一个元素的长度（也就是移动一个指针的长度,指向的就是第二个指针的首地址，也就是arr2的首地址）</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
</div></code></pre>
<p>首先应当先解引用<code>*p</code>，现在<code>*p</code>表示的是<code>arr1</code>的首地址，也就是第一个元素，然后通过指针的运算获得后面的元素的地址 ，随后在进行解引用得到他所拥有的数据，在内层循环外部通过<code>p++</code>表示加上一个指针的长度，这样就可以有效的过渡到第二个数组<code>arr2</code>,因此这么写是✔</p>
<p>为什么使用指针接受数组可以<code>p++</code>操作，但是如果是直接<code>arr++</code>就不行？</p>
<p>因为如果是<code>int *p = arr</code>,这里的<code>p</code>是一个指针的变量，可以进行操作，但是<code>arr</code>是一个固定的地址，表示的是指向数组首地址的指针，这个是不能够操作的。</p>
<ul>
<li>数组指针和指针数组
<ol>
<li>数组指针：指向数组的指针
<ol>
<li>一维数组：<code>int *p = arr</code>,步长为<code>sizeof(int)</code></li>
<li>二维数组：<code>int (*p)[5] = &amp;arr(arr)</code>步长为<code>sizeof(int arr[5])</code></li>
</ol>
</li>
<li>指针数组：存放指针的数组<code>int *arr = {arr1,arr2};``int *p[5]</code></li>
</ol>
</li>
</ul>
<h3 id="%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%88%B0%E5%87%BD%E6%95%B0%E4%B8%AD">数组作为指针传递到函数中</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>])</span></span>;
</div></code></pre>
<p>这一些都是正确的这里的<code>a</code>都是作为指针<code>int *</code></p>
<p>同样的，二维数组也可以作为参数传递到函数中</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*a)[N])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[][N])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][N])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>][N])</span></span>;
<span class="hljs-comment">// 因为这个地方的a[M]都会被隐式转换成为(*a)</span>
</div></code></pre>
<p>这一些都是可以的</p>
<h2 id="%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98">动态内存</h2>
<p>计算机中存在多个内存的区域，其中最常见的区域是栈(stack)和堆(heap)</p>
<p>stack的内存由编译器自动管理。stack内存的分配和释放速度都非常快，因为他遵循后进先出的原则，但是他的内存通常较小，而且是固定的</p>
<p>heap内存通过程序员手动管理，使用<code>malloc</code>,<code>calloc</code>,<code>new</code>等函数的分配，使用<code>free</code>,<code>delete</code>进行删除。</p>
<h3 id="malloc%E5%87%BD%E6%95%B0"><code>malloc</code>函数</h3>
<p>在<code>&lt;stdlib.h&gt;</code>中的定义<code>void * malloc(size_t size)</code></p>
<p>其中的<code>size_t</code>的变量就相当于<code>unsigned int</code>.</p>
<pre class="hljs"><code><div>T *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(T)*n);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i!=n;i++)
{
    ptr[i] = ····
}
<span class="hljs-built_in">free</span>(ptr);
</div></code></pre>
<h3 id="%E4%BD%BF%E7%94%A8malloc%E5%87%BD%E6%95%B0%E7%94%B3%E8%AF%B7%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84">使用<code>malloc</code>函数申请一个数组</h3>
<ul>
<li>一维数组</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> *arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">5</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)
    {
        arr[i] = i;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, arr[i]);
    }
    <span class="hljs-built_in">free</span>(arr);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li>二维数组
<ul>
<li>使用连续申请的方式来进行申请<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> **arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *) * <span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)
        arr[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">5</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)
            arr[i][j] = <span class="hljs-number">3</span> * i * j;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, arr[i][j]);
        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)
        <span class="hljs-built_in">free</span>(arr[i]);<span class="hljs-comment">//释放每一行内存</span>
    <span class="hljs-built_in">free</span>(arr[i]);<span class="hljs-comment">//释放储存指针的数组</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
</li>
<li>使用计算的方式来申请<pre class="hljs"><code><div><span class="hljs-keyword">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * n * m);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)
        p[i * m + j] = <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// This is the (i, j)-th entry.</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">free</span>(p);
</div></code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="malloc%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><code>malloc()</code>的返回值</h4>
<ul>
<li>当<code>malloc</code>尝试分配一块非常大的内存的时候，如果系统没有足够的(heap)来存放内存，<code>malloc</code>就会返回一个空指针，可以通过确定返回的指针是否是空指针来确定是否存在充足的内存可以使用</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 尝试分配一个非常大的内存块</span>
    <span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1u</span>ll &lt;&lt; <span class="hljs-number">60</span>); 
    <span class="hljs-keyword">if</span> (!ptr) {
        <span class="hljs-comment">// 检查是否分配失败</span>
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Out of memory.\n"</span>); 
    }
    <span class="hljs-keyword">if</span> (ptr) {
        <span class="hljs-built_in">free</span>(ptr); <span class="hljs-comment">// 如果分配成功，释放内存</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="calloc%E5%87%BD%E6%95%B0"><code>calloc</code>函数</h3>
<ul>
<li><code>void *calloc(size_t num,size_t each_size);</code>和<code>malloc(num*each_size)</code>相同的含义，但是他将所有的内容都初始化为相应的空元素（<code>int : 0 ;char:'\0'</code>）</li>
</ul>
<h3 id="free%E5%87%BD%E6%95%B0"><code>free</code>函数</h3>
<p><code>free</code>函数的作用是释放内存，但是需要注意的是，<code>free</code>函数只能释放由<code>malloc</code>,<code>calloc</code>,<code>new</code>等函数申请的内存，不能释放其他的内存。</p>
<ul>
<li>注意<code>free</code>不能够重复释放内存（<strong>未定义行为</strong>）</li>
<li><code>free</code>不能够一个一个地释放<code>malloc</code>出来的相应的地址</li>
<li>在调用<code>free</code>函数之前不需要进行检查，因为<code>free(NULL)</code>是安全的们不会导致任何错误，然而这部不意味着可以重复调用<code>free</code>函数。</li>
</ul>
<h3 id="%E4%BC%A0%E5%85%A50%E4%B8%AA%E9%9C%80%E8%A6%81%E5%88%86%E9%85%8D%E7%9A%84%E7%A9%BA%E9%97%B4%E4%BC%9A%E6%80%8E%E6%A0%B7">传入0个需要分配的空间会怎样？</h3>
<ul>
<li><code>malloc(0)</code>的行为是由编译器决定的。这意味着不同的编译器可能存在不同的处理方式。他可能返回一个空指针，表示没有分配任何内存；也可能返回一个非空的指针。这样也会导致内存泄露的问题，因为如果返回了一个非空的指针，而这个时候你没有使用<code>free</code>函数将这一块空间释放，这样就会导致内存泄漏。</li>
<li>和<code>malloc</code>一样<code>calloc(0,N);</code>也是根据编译器来选择不同行为的。</li>
<li><code>free(NULL)</code>是安全的，不会产生任何副作用，但是不能够重复释放同一个内存。</li>
</ul>
<h2 id="%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</h2>
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E0">字符串与<code>\0</code></h3>
<ul>
<li><code>\0</code>表示的是字符串的结束，在使用<code>char str[15] = &quot;This is me&quot;</code>来储存字符的时候一定要考虑到<code>\0</code>算作其中的一个元素（如果少了会导致在输出的时候存在<strong>未定义行为</strong>）。</li>
<li>同样的<code>printf(&quot;%s&quot;,str);</code>的时候会在<code>\0</code>的地方停下来，所以如果没有<code>\0</code>的时候就会导致未定义行为（数组越界）</li>
<li><code>char empty[] = &quot;&quot;;</code>这里<code>empty</code>的大小是1，因为要包括<code>\0</code>.</li>
<li>字符串的读入和修改</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>] = <span class="hljs-string">"abcdef"</span>;
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,str);<span class="hljs-comment">//reads "123" ,str becomes {'1','2','3','\0','e','f'}</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>,str);<span class="hljs-comment">//prints "123"</span>
</div></code></pre>
<p><code>scanf()</code>函数<strong>并不安全</strong>，<code>scnaf()</code>在读取字符串的时候仅仅是将它转换成为了一个指针来传递，并不知道这个字符串的大小，所以不能够检查时候会超过<code>char str[10]</code>的内部的空间。</p>
<h3 id="gets%E4%B8%8Efgets"><code>gets</code>与<code>fgets</code></h3>
<p><code>gets</code>没有边界检查，所以不推荐使用，和<code>gets</code>一样的有<code>get_s</code>但是这个斌不是在所有的编译器中都能使用的。</p>
<p><code>fgets</code>是一个更加安全的函数，它的使用方法是</p>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];
fgets{str,<span class="hljs-number">100</span>,<span class="hljs-built_in">stdin</span>};
</div></code></pre>
<p>这里的<code>fgets</code>就只会最多读取99位字符。</p>
<p>According to the cppreference documentation for <code>fgets</code>:</p>
<p>It reads at most <code>size -1</code>characters.Here <code>size</code>is the number of elements specified as an arguement(typically the size of the buffer).This leaves space for the null terminator(\0).</p>
<p>It stops unber one of these conditions:</p>
<ul>
<li>When it reads a newline characters</li>
<li>when it reaches the end of the file</li>
<li>When it has read <code>size-1</code>characters</li>
</ul>
<h3 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><a href="https://zh.cppreference.com/w/c/string/byte">字符串的相关函数</a></h3>
<p>在<code>&lt;ctype.h&gt;</code>中定义的</p>
<ul>
<li><code>islower</code>:检查是否是小写字符，如果是小写字母，返回非零值；否则返回 0。</li>
<li><code>isupper</code>:检查是否是大写字母，若为大写字母，返回非零值；反之返回 0。</li>
<li><code>isspace</code>:该函数用于检查字符是否为空白字符，空白字符包括空格、制表符、换行符等。如果是空白字符，返回非零值；否则返回 0。</li>
<li><code>ispunct</code>:此函数用于检查字符是否为标点字符。若为标点字符，返回非零值；反之返回 0</li>
<li><code>tolower</code>:该函数用于将大写字母转换为小写字母。如果传入的字符是大写字母，则返回对应的小写字母；否则返回原字符。</li>
<li><code>toupper</code>:此函数用于将小写字母转换为大写字母。若传入的字符是小写字母，则返回对应的大写字母；否则返回原字符。</li>
</ul>
<p>在<code>&lt;stdlib.h&gt;</code>中定义</p>
<ul>
<li>
<p><strong><code>strto+'···'</code></strong>:</p>
<ul>
<li><code>strtol</code>:The function prototype is <code>long strtol(const char *nptr,char **endptr,int base)</code>.It converts a string to a <code>long long</code> value in the specified <code>base</code>(radix,ranging from 2 to 36,or 0 for auto-detection).(字符串一开始<code>0</code>表示八进制，字符串一开始<code>0x</code>表示16进制)It skips leading whitespce,starts conversion at digits/signs,and stops at non-digit characters or <code>\0</code>,If <code>endptr</code> isn't <code>NULL</code>,it stores the pointer to the character after the conversion end.(<code>endptr</code>表示的就是遇到第一个不满足条件的字符，随后停止转换，如果这里写<code>NULL</code>,表示遇到不满足的条件的时候直接返回<code>NULL</code>,没有指针指向它)</li>
<li><code>strtoul</code>:<code>unsigned long strtoul(const char *nptr,char **endptr ,int base)</code></li>
<li><code>strtoull</code>:<code>unsigned long long strtoull (const char*nptr,char**endptr,int base)</code></li>
<li><code>strof</code>:<code>double strtod(const char *nptr,char **endptr)</code>这里就不存在转换进制的功能。</li>
<li><code>strtold</code>:<code>long double strtole(const char *nptr,char **endptr)</code></li>
</ul>
</li>
<li>
<p><code>snprintf</code>:<code>snprintf(str,sizof(str),&quot;%f&quot;,num);</code>根据字符串<code>format</code>格式将数据格式化输出到<code>str</code>中，最多写入<code>size-1</code>个字符串，并且在末尾添加上<code>'\0'</code>.</p>
</li>
</ul>
<p>在<code>&lt;string.h&gt;</code>中定义</p>
<ul>
<li><code>strcpy(dest,src)</code>将字符串<code>src</code>复制到<code>dest</code>中。包含结束符<code>'\0'</code>.</li>
<li><code>strncpy(dest,src,5);</code>从源字符串 src 复制最多 n 个字符到目标字符串 dest 中。如果 src 的长度小于 n，则用 '\0' 填充 dest 直到复制了 n 个字符；如果 src 的长度大于等于 n，则<strong>不会</strong>在 dest 末尾添加 '\0' <em>If <code>dest</code> and <code>src</code> point to the same memory address, <code>strcpy</code> will still work correctly because it copies the <code>null</code> terminator (<code>\0</code>) from <code>src</code> to <code>dest</code>. The result will be the same string in the same memory location.</em></li>
<li><code>strcat(dest,src)</code>将源字符串 src 连接到目标字符串 dest 的末尾，覆盖 dest 末尾的 '\0'，并在连接后的字符串末尾添加新的 '\0'。</li>
<li><code>strncat(dest,src,3)</code>将源字符串 src 的最多 n 个字符连接到目标字符串 dest 的末尾，并在连接后的字符串末尾添加 '\0'。如果 src 的长度小于 n，则将整个 src 连接到 dest 末尾。</li>
<li><code>size_t len = strlen(str)</code>返回给定的字符串的长度(不包括<code>'\0'</code>)注意<code>strlen()</code>的运算速度很慢，不要总是调用这个函数。</li>
<li><code>strcmp(s1,s2)</code>比较两个字符串 s1 和 s2 的大小。如果 s1 小于 s2，返回一个负数；如果 s1 等于 s2，返回 0；如果 s1 大于 s2，返回一个正数。(<em>The result of the result is not limited to -1,0,or 1</em>.)</li>
<li><code>strchr</code>查找第一次出现的指定元素，并返回<code>char *</code>类型的地址</li>
<li><code>strrchr</code>查找最后一次出现的指定元素</li>
<li><code>strstr(haystack,needle)</code>在字符串 haystack 中查找子字符串 needle 首次出现的位置，并返回指向该位置的指针。如果未找到，则返回 NULL。</li>
</ul>
<p>Some tips:Overlapping memory:</p>
<ul>
<li>
<p><code>strcpy</code> with overlapping memory:</p>
<p><em>This is <strong>undefined behavior</strong>. The C standard does not guarantee correct behavior when memory regions overlap. The function might overwrite parts of the source string before copying them.</em></p>
</li>
<li>
<p><code>strncpy</code> with overlapping memory:</p>
<p><em>This is also <strong>undefined behavior</strong>. While strncpy limits the number of characters copied, it still doesn't handle overlapping memory safely.</em></p>
</li>
<li>
<p><code>strcat</code> with overlapping memory:</p>
<p><em>This is <strong>undefined behavior.</strong> strcat first finds the end of dest and then appends src. If the memory regions overlap, it might overwrite parts of src before copying them.</em></p>
</li>
</ul>
<h3 id="can-or-cannot-change">Can or Cannot change?</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">char</span> *str_1 = <span class="hljs-string">"Liyiming"</span>;
    <span class="hljs-keyword">char</span> str_2[] = <span class="hljs-string">"Liyiming"</span>;<span class="hljs-comment">//It copies the whole string to the array `str_2`.</span>
    str_1[<span class="hljs-number">4</span>] = <span class="hljs-string">'M'</span><span class="hljs-comment">//No compile-error,but undefined behaviors.The string connot change</span>
    str_2[<span class="hljs-number">4</span>] = <span class="hljs-string">'M'</span><span class="hljs-comment">//Correct! The array can change.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>The change of the string can lead to the severe runtime-error.</p>
<p>There are some ways to protect it:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = <span class="hljs-string">"abcde"</span>;
str[<span class="hljs-number">3</span>] = <span class="hljs-string">'a'</span>;<span class="hljs-comment">//compile error</span>
</div></code></pre>
<h3 id="array-of-strings">Array of strings</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *translations[] = {
        <span class="hljs-string">"zero"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>,
        <span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>, <span class="hljs-string">"seven"</span>, <span class="hljs-string">"eight"</span>, <span class="hljs-string">"nine"</span>};
</div></code></pre>
<p>Notes that <code>translation</code> is an array of pointers, where each pointer points to a string literal.<code>translations</code> is not a 2-d array.</p>
<h2 id="struct">Struct</h2>
<ul>
<li>结构体可以理解为自定义的数据类型，他是由一批数据组合成为的结构性数据。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构体名称
{</span>
   成员<span class="hljs-number">1</span>;
   成员<span class="hljs-number">2</span>;
   ···
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GirlFriend</span>
{</span>
    <span class="hljs-keyword">char</span> name[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">char</span> gender;
    <span class="hljs-keyword">double</span> <span class="hljs-built_in">height</span>;
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
   <span class="hljs-keyword">char</span> name[<span class="hljs-number">30</span>];
   <span class="hljs-keyword">int</span> age;
   <span class="hljs-keyword">double</span> <span class="hljs-built_in">height</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">/*
        结构体：
            自定义的数据类型
            就是由很多的数据组合成为的一个整体
            每一个数据，都是结构体的成员
        书写的位置：
            函数里面：局部位置只能在本函数中使用
            函数外面：在所有的函数中都可以使用
    */</span>
   <span class="hljs-comment">// 使用结构体</span>
   <span class="hljs-comment">// 定义一个类型的变量</span>
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GirlFriend</span> <span class="hljs-title">gf1</span>;</span>
   <span class="hljs-built_in">strcpy</span>(gf1.name, <span class="hljs-string">"aaa"</span>);<span class="hljs-comment">//字符串的赋值需要注意</span>
   gf1.age = <span class="hljs-number">21</span>;
   gf1.gender = <span class="hljs-string">'F'</span>;
   gf1.<span class="hljs-built_in">height</span> = <span class="hljs-number">1.63</span>;
   <span class="hljs-comment">//---------------------------------</span>
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">stu1</span> = {</span><span class="hljs-string">"Sam"</span>,<span class="hljs-number">18</span>,<span class="hljs-number">175.26</span>};
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">stu2</span> = {</span><span class="hljs-string">"Lily"</span>,<span class="hljs-number">17</span>,<span class="hljs-number">16.35</span>};
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">strArr</span>[2] = {</span>stu1,stu2};
   <span class="hljs-comment">// 遍历每一个元素</span>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>; i++)
   {
      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">temp</span> = <span class="hljs-title">strArr</span>[<span class="hljs-title">i</span>];</span>
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %d %lf"</span>,temp.name,temp.age,temp.<span class="hljs-built_in">height</span>);
   }
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%AB%E5%90%8D">结构体的别名</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">struct</span> <span class="hljs-params">(Name)</span><span class="hljs-comment">//name可以写也可以不写</span>
</span>{
   <span class="hljs-keyword">char</span> name[<span class="hljs-number">100</span>];
   <span class="hljs-keyword">int</span> age;
   <span class="hljs-keyword">char</span> gender;
   <span class="hljs-keyword">double</span> <span class="hljs-built_in">height</span>;
}GF;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ultram</span>
{</span>
    <span class="hljs-keyword">char</span> name[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">int</span> attack;
    <span class="hljs-keyword">int</span> defense;
    <span class="hljs-keyword">int</span> blood;
} M;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    M taro = {<span class="hljs-string">"Laitor"</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">500</span>};
    M rem = {<span class="hljs-string">"rem"</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">450</span>};
    M arr[<span class="hljs-number">2</span>] = {taro, rem};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
    {
        M temp = arr[i];
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %d %d %d\n"</span>, temp.name, temp.attack, temp.defense, temp.blood);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li>相当于在这里我们将<code>struct Ultram</code>改成了<code>M</code>.</li>
</ul>
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">结构体作为函数的参数</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    <span class="hljs-keyword">char</span> name[<span class="hljs-number">30</span>];
    <span class="hljs-keyword">int</span> age;
} stu;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(stu *st)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    stu stu1;
    <span class="hljs-built_in">strcpy</span>(stu1.name, <span class="hljs-string">"Liyiming"</span>);
    stu1.age = <span class="hljs-number">18</span>;
    change(&amp;stu1);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The name of stu1 is %s\n"</span>, stu1.name);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The age of stu1 is %d\n"</span>, stu1.age);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(stu *st)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The name of stu1 is %s\n"</span>, (*st).name);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The age of stu1 is %d\n"</span>, (*st).age);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, (*st).name);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;(*st).age);
}
</div></code></pre>
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97">结构体的嵌套</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Message</span>
{</span>
    <span class="hljs-keyword">char</span> phone[<span class="hljs-number">12</span>];
    <span class="hljs-keyword">char</span> school_mail[<span class="hljs-number">100</span>];
};

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    <span class="hljs-keyword">char</span> name[<span class="hljs-number">30</span>];
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Message</span> <span class="hljs-title">msg</span>;</span>
} stu;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(stu *st)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    stu stu1;
    <span class="hljs-built_in">strcpy</span>(stu1.name, <span class="hljs-string">"Liyiming"</span>);
    stu1.age = <span class="hljs-number">18</span>;
    <span class="hljs-built_in">strcpy</span>(stu1.msg.phone, <span class="hljs-string">"17775756985"</span>);
    <span class="hljs-built_in">strcpy</span>(stu1.msg.school_mail, <span class="hljs-string">"liym2024@shanghaitech.edu.cn"</span>);
    change(&amp;stu1);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, stu1.msg.school_mail);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">/*
    stu stu2 = {"Liyiming",18,{"17775756985","liym2024@shanghaitech.edu.cn"}};
    */</span>
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(stu *st)</span>
</span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, (*st).msg.school_mail);
}
</div></code></pre>
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">结构体的内存对齐</h3>
<ul>
<li>确定变量的位置：
<ol>
<li>总体上还是按照定义的顺序从前到后的安排内存地址</li>
<li>每一个变量只能放在自己类型整数倍的内存地址上（中间空出来的字节会被补位空白字符）</li>
</ol>
</li>
<li>最后一个补位：结构体的总大小，是最大类型的整数倍</li>
<li>补位并不会改变相应的类型的变量的大小</li>
<li>其实不只是在结构体中，只要是储存变量就会存在内存对齐的情况</li>
<li>综上：我们将小的数据类型写在上面，大的数据类型写在下面（节省空间）</li>
</ul>
<blockquote>
<p>The jorney is to be continued! -- YiMing Li</p>
</blockquote>

</body>
</html>
