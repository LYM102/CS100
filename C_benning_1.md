# C_beginning_1
## 了解`scanf()`
- `scanf("%d %d",&a,&b);`和`scanf("%d%d",&a,&b);`之间到底是什么关系？
   1. 在C中`' '`,`'\n'`,`'\f'`,`'\t'`,`'\v'`;这几个都叫做空白字符，而在`scanf`中的`%d`和空白字符可以跳过任意的空白字符
   2. 当且仅当遇到下一个非空字符的时候才会去对应到下一个值，或推退出语句
- `scanf()`的返回值
   - 如果`scnaf()`返回值是合法的，`scanf()`的返回值和预期输入数量匹配。
   - 如果`scnaf()`返回值是非法的，`scnaf()`的返回值是零。
**示例**
```c
int num;
float fnum;
int result = scanf("%d %f", &num, &fnum);
if (result == 2) {
    // 输入合法
} else {
    // 输入不合法
}
```
```c
int num;
int result = scanf("%d", &num);
if (result == EOF) {
    // 输入结束或错误
}
```
## 数据类型
### 不同类型的字节大小
| 数据类型              | 32位 | 64位 | 说明                                                                 |
|:---------------------:|:----:|:----:|:-------------------------------------------------------------------:|
| `char`                | 1    | 1    | 始终为 1 字节，表示单个字符。                                        |
| `short int`           | 2    | 2    | 通常为 2 字节，表示短整数。                                          |
| `int`                 | 4    | 4    | 通常为 4 字节，表示整数。                                            |
| `long int`            | 4    | 8    | 在 32 位系统中通常为 4 字节，在 64 位系统中通常为 8 字节，表示长整数。|
| `long long int`       | 8    | 8    | 始终为 8 字节，表示长长整数。                                        |
| `float`               | 4    | 4    | 始终为 4 字节，表示单精度浮点数。                                    |
| `double`              | 8    | 8    | 始终为 8 字节，表示双精度浮点数。                                    |
| `long double`         | 12 或 16 | 16 | 在 32 位系统中通常为 12 或 16 字节，在 64 位系统中通常为 16 字节，表示扩展精度浮点数。 |
| `unsigned char`       | 1    | 1    | 始终为 1 字节，表示无符号字符。                                      |
| `unsigned short`      | 2    | 2    | 通常为 2 字节，表示无符号短整数。                                    |
| `unsigned int`        | 4    | 4    | 通常为 4 字节，表示无符号整数。                                      |
| `unsigned long`       | 4    | 8    | 在 32 位系统中通常为 4 字节，在 64 位系统中通常为 8 字节，表示无符号长整数。 |
| `unsigned long long`  | 8    | 8    | 始终为 8 字节，表示无符号长长整数。                                  |
| `void*`               | 4    | 8    | 在 32 位系统中通常为 4 字节，在 64 位系统中通常为 8 字节，表示指针。  |
| `_Bool`               | 1    | 1    | 始终为 1 字节，表示布尔值（0 或 1）。                                |
| `enum`                | 通常与 `int` 相同 | 通常与 `int` 相同 | 枚举类型的大小通常与 `int` 类型相同。                                |

### 不同类型的格式转换符（占位符）

| 数据类型              | `printf` 占位符 | `scanf` 占位符 | 示例值             | 示例代码（`printf`）                    | 示例代码（`scanf`）                     |
|:---------------------:|:---------------:|:--------------:|:------------------:|:---------------------------------------:|:---------------------------------------:|
| `char`                | `%c`            | `%c`           | `'A'`              | `printf("%c", 'A');`                    | `scanf("%c", &ch);`                     |
| `int`                 | `%d` 或 `%i`    | `%d` 或 `%i`   | `42`               | `printf("%d", 42);`                     | `scanf("%d", &num);`                    |
| `unsigned int`        | `%u`            | `%u`           | `42`               | `printf("%u", 42);`                     | `scanf("%u", &unum);`                   |
| `short int`           | `%hd`           | `%hd`          | `42`               | `printf("%hd", (short)42);`             | `scanf("%hd", &snum);`                  |
| `unsigned short`      | `%hu`           | `%hu`          | `42`               | `printf("%hu", (unsigned short)42);`    | `scanf("%hu", &usnum);`                 |
| `long int`            | `%ld`           | `%ld`          | `42L`              | `printf("%ld", 42L);`                   | `scanf("%ld", &lnum);`                  |
| `unsigned long`       | `%lu`           | `%lu`          | `42L`              | `printf("%lu", 42L);`                   | `scanf("%lu", &ulnum);`                 |
| `long long int`       | `%lld`          | `%lld`         | `42LL`             | `printf("%lld", 42LL);`                 | `scanf("%lld", &llnum);`                |
| `unsigned long long`  | `%llu`          | `%llu`         | `42LL`             | `printf("%llu", 42LL);`                 | `scanf("%llu", &ullnum);`               |
| `float`               | `%f`            | `%f`           | `3.14f`            | `printf("%f", 3.14f);`                  | `scanf("%f", &fnum);`                   |
| `double`              | `%f` 或 `%lf`   | `%lf`          | `3.14`             | `printf("%f", 3.14);`                   | `scanf("%lf", &dnum);`                  |
| `long double`         | `%Lf`           | `%Lf`          | `3.14L`            | `printf("%Lf", 3.14L);`                 | `scanf("%Lf", &ldnum);`                 |
| `char[]` 或 `char*`   | `%s`            | `%s`           | `"Hello"`          | `printf("%s", "Hello");`                | `scanf("%s", str);`                     |
| `void*`               | `%p`            | N/A            | `&var`             | `printf("%p", &var);`                   | N/A                                     |
| `_Bool`               | `%d`            | `%d`           | `true` 或 `false`  | `printf("%d", true);`                   | `scanf("%d", &boolvar);`                |

### 不同进制的表示方式

| 类型                  | 十六进制         | 八进制           | 十进制             |
|:---------------------:|:----------------:|:----------------:|:------------------:|
| `char`                | `\x41`           | `\0101`          | `\65`/`65`         |
| `int`                 | `0x41`           | `0101`           | `65`               |
| `unsigned int`        | `0x41u`          | `0101u`          | `65u`              |
| `long`                | `0x41L`          | `0101L`          | `65L`              |
| `unsigned long`       | `0x41UL`         | `0101UL`         | `65UL`             |
| `long long`           | `0x41LL`         | `0101LL`         | `65LL`             |
| `unsigned long long`  | `0x41ULL`        | `0101ULL`        | `65ULL`            |
| `float`               | `0x1.9p-4f`      | `01.443242e-4f`  | `6.5f`             |
| `double`              | `0x1.9p-4`       | `01.443242e-4`   | `6.5`              |
| `unsigned float`      | `0x1.9p-4uf`     | `01.443242e-4uf` | `6.5uf`            |
| `long double`         | `0x1.9p-4L`      | `01.443242e-4L`  | `6.5L`             |
| `unsigned long double`| `0x1.9p-4uL`     | `01.443242e-4uL` | `6.5uL`            |
### C语言逻辑运算结果类型及与int的关系
- C语言逻辑运算结果类型及与int的关系:
在C语言中，逻辑运算的结果类型和值有明确的定义。即使在C99标准引入布尔类型后，逻辑运算的结果仍然可以被看作是int类型。以下是详细解释。
1. C99标准引入的布尔类型
  - C99标准引入了`_Bool`类型，表示布尔值（`true`或`false`），并通过`stdbool.h`头文件提供了`bool`类型别名，以及`true`和`false`宏定义。例如：
```c
#include <stdbool.h>
bool flag = true;
```
  - _Bool类型是一个独立的类型，其大小通常为1字节，且只有两个可能的值：`true`（非零值）`false`（零值）
2. 逻辑运算的结果类型
- 尽管引入了布尔类型，但C语言的逻辑运算（`&&`、`||`、`!`）的结果类型仍然是`int`，而不是`_Bool`。原因如下：
  - 历史兼容性：C语言的逻辑运算结果一直是`int`类型，为了保持与早期代码的兼容性，C99标准没有改变这一行为。
  - 隐式转换：在C语言中，`_Bool`类型可以隐式转换为`int`类型，反之亦然。因此，即使逻辑运算的结果是int类型，它也可以被用在布尔上下文中。
3. 逻辑运算结果的值
逻辑运算的结果值仍然是0或1：

   - 0表示false（假）。

   - 1表示true（真）。

    这意味着，即使你使用bool类型来存储逻辑运算的结果，它也会被隐式转换为int类型。例如：
```c
#include <stdio.h>
#include <stdbool.h>

int main() {
    bool result = (5 > 3); // 逻辑运算结果为 1（true）
    printf(" =result %d\n", result); // 输出 1
    printf("sizeof(result) = %zu\n", sizeof(result)); // 输出 1（_Bool类型大小）
    
    int int_result = (5 > 3); // 逻辑运算结果为 1（int类型）
    printf("int_result = %d\n", int_result); // 输出 1
    printf("sizeof(int_result) = %zu\n", sizeof(int_result)); // 输出 4（int类型大小）

    return 0;
}
```
4. 为什么可以将结果看作`int`类型
- 类型兼容性：`_Bool`类型和`int`类型之间可以隐式转换。`_Bool`类型在存储时通常会被提升为`int`类型，因此逻辑运算的结果（`int`类型）可以直接赋值给`_Bool`类型变量。
- 值兼容性：逻辑运算的结果只有0和1，这两个值在`int`类型和`_Bool`类型中都具有相同的语义。
### 计算时的隐式转换
- `char`和`short`类型在运算的时候发生隐式转换位`int`。但是只会在计算或者比较大小的时候发生转变，在计算完成之后就还是原来的类型。
```c
#include <stdio.h>

int main() {
    char a = 5;
    char b = 10;
    char c = a + b;//先变成int，再变成char

    printf("a + b = %d\n", c);
    return 0;
}
```
```c
#include <stdio.h>

int main() {
    short a = 5;
    short b = 10;
    short c = a + b;//会先转换为int然后再变成short

    printf("a + b = %d\n", c);
    return 0;
}
```
### 未定义的情况
1. 超过范围的情况：例如int超过范围
2. 未使用正确的占位符
3. `i++ + ++i`的情况
```c
#include <stdio.h>

int main()
{
    int a = 64;
    char b = 64;
    long long c = 64LL;
    float d = 64.00;
    double e = 64.00;
    unsigned int f = 64;
    short g = 64;
    printf("%f,%lld,%c,%hd,%u\n", a, a, a, a, a);
    printf("%f,%lld,%d,%hd,%u\n", b, b, b, b, b);
    printf("%f,%d,%c,%hd,%u\n", c, c, c, c, c);
    printf("%d,%lld,%c,%hd,%u\n", d, d, d, d, d);
    printf("%d,%lld,%c,%hd,%u\n", e, e, e, e, e);
}
```
```
0.000000,64,@,64,64
0.000000,64,64,64,64
0.000000,64,@,64,64
0,4634204016564240384,,0,0
0,4634204016564240384,,0,0
```
## 运算符
### 运算符的优先级和结合性
以下是C语言中不同运算符的优先级和结合性：

| 优先级 | 运算符                  | 描述                       | 结合性       |
|:------:|:-----------------------:|:--------------------------:|:------------:|
| 1      | `()`                    | 圆括号                     | 从左到右     |
| 2      | `[]`                    | 数组下标                   | 从左到右     |
| 2      | `.`                     | 结构体成员访问             | 从左到右     |
| 2      | `->`                    | 结构体指针成员访问         | 从左到右     |
| 2      | `++`                    | 后置递增                   | 从左到右     |
| 2      | `--`                    | 后置递减                   | 从左到右     |
| 3      | `++`                    | 前置递增                   | 从右到左     |
| 3      | `--`                    | 前置递减                   | 从右到左     |
| 3      | `+`                     | 一元加                     | 从右到左     |
| 3      | `-`                     | 一元减                     | 从右到左     |
| 3      | `!`                     | 逻辑非                     | 从右到左     |
| 3      | `~`                     | 按位取反                   | 从右到左     |
| 3      | `*`                     | 指针解引用                 | 从右到左     |
| 3      | `&`                     | 取地址                     | 从右到左     |
| 3      | `sizeof`                | 求大小                     | 从右到左     |
| 3      | `(type)`                | 类型转换                   | 从右到左     |
| 4      | `*`                     | 乘法                       | 从左到右     |
| 4      | `/`                     | 除法                       | 从左到右     |
| 4      | `%`                     | 取模                       | 从左到右     |
| 5      | `+`                     | 加法                       | 从左到右     |
| 5      | `-`                     | 减法                       | 从左到右     |
| 6      | `<<`                    | 左移                       | 从左到右     |
| 6      | `>>`                    | 右移                       | 从左到右     |
| 7      | `<`                     | 小于                       | 从左到右     |
| 7      | `<=`                    | 小于等于                   | 从左到右     |
| 7      | `>`                     | 大于                       | 从左到右     |
| 7      | `>=`                    | 大于等于                   | 从左到右     |
| 8      | `==`                    | 等于                       | 从左到右     |
| 8      | `!=`                    | 不等于                     | 从左到右     |
| 9      | `&`                     | 按位与                     | 从左到右     |
| 10     | `^`                     | 按位异或                   | 从左到右     |
| 11     | `\|`                     | 按位或                     | 从左到右     |
| 12     | `&&`                    | 逻辑与                     | 从左到右     |
| 13     | `\|\|`                    | 逻辑或                     | 从左到右     |
| 14     | `?:`                    | 条件运算符                 | 从右到左     |
| 15     | `=`                     | 赋值                       | 从右到左     |
| 15     | `+=` `-=` `*=` `/=` `%=`| 复合赋值运算符             | 从右到左     |
| 15     | `<<=` `>>=` `&=` `^=` `\|=`| 复合赋值运算符             | 从右到左     |
| 16     | `,`                     | 逗号运算符                 | 从左到右     |
### 算数运算与算数运算的左连接问题
```c
#include <stdio.h>

int main()
{
    int ival = 100000;
    long long llval = ival;
    int res1 = ival * ival;
    long long res2 = ival * ival;//运算结果是int再显示转换为longlong还是会溢出
    long long res3 = llval * ival;//在运算的时候ival隐式转换成long long在进行计算
    long long res4 = llval * ival * ival;//注意是从左向右的方式进行两个ival依次被转换成longlong类型
    printf("%d\n%lld\n%lld\n%lld\n", res1, res2, res3, res4);
    /*
    1410065408
    1410065408
    10000000000
    1000000000000000
    */
}
```
### 赋值运算的右连接问题
```c
#include <stdio.h>

int main()
{
    int a = 0, b = 1, c = 2;
    a = b = c;
    printf("%d %d %d", a, b, c);//2 2 2
    // 赋值运算从右往左进行
}
```
### 未定义的函数调用顺序
```c
#include <stdio.h>
int func1(void)
{
    printf("Func1 is called\n");
    return 2;
}
int func2(void)
{
    printf("Func2 is called\n");
    return 3;
}
int func3(void)
{
    printf("Func3 is called\n");
    return 4;
}
int main()
{
    int c = func1() + (func2() * func3());
    return 0;
}
```
```
Func1 is called
Func2 is called
Func3 is called
```
- Operater precedence does not determine evaluation order:`f()+g()*h()` is interpreted as `f() + (g() * h())`,but the order in which `f`,`g`,`h` are called is unspecified.
- 个人的情况，其实我觉得函数的调用应该还是按照从左往右的顺序进行，但是如果是遇到逻辑判断则会出现短路现象（只要能够判断是否是真或者是假就会跳过相关的函数的调用）
### 位运算符
在C语言中，位运算符用于直接操作整数的二进制位。以下是常见的位运算符及其示例：

#### 1. 按位与 (`&`)
对两个操作数的每个二进制位进行与操作，结果为1仅当两个位都为1。

**示例：**
```c
int a = 5;    // 二进制: 0101
int b = 3;    // 二进制: 0011
int c = a & b; // 结果: 0001 (十进制 1)
```

#### 2. 按位或 (`|`)
对两个操作数的每个二进制位进行或操作，结果为1只要有一个位为1。

**示例：**
```c
int a = 5;    // 二进制: 0101
int b = 3;    // 二进制: 0011
int c = a | b; // 结果: 0111 (十进制 7)
```

#### 3. 按位异或 (`^`)
对两个操作数的每个二进制位进行异或操作，结果为1当两个位不同。

**示例：**
```c
int a = 5;    // 二进制: 0101
int b = 3;    // 二进制: 0011
int c = a ^ b; // 结果: 0110 (十进制 6)
```

#### 4. 按位取反 (`~`)
对操作数的每个二进制位进行取反操作，1变0，0变1。

**示例：**
```c
int a = 5;    // 二进制: 0101
int b = ~a;   // 结果: 1010 (假设int为4位，十进制 -6)
```

#### 5. 左移 (`<<`)
将操作数的二进制位向左移动指定位数，右侧补0。

**示例：**
```c
int a = 5;    // 二进制: 0101
int b = a << 1; // 结果: 1010 (十进制 10)
```

#### 6. 右移 (`>>`)
将操作数的二进制位向右移动指定位数，左侧补0（无符号数）或补符号位（有符号数）。

**示例：**
```c
int a = 5;    // 二进制: 0101
int b = a >> 1; // 结果: 0010 (十进制 2)
```

#### 总结
- `&`：按位与
- `|`：按位或
- `^`：按位异或
- `~`：按位取反
- `<<`：左移
- `>>`：右移
这些运算符常用于底层编程，如硬件操作、数据压缩和加密等场景。
---
```c

```